#!/usr/bin/python3

# Copyright © 2016 Jakub Wilk <jwilk@jwilk.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import configparser
import json
import os
import subprocess
import sys
import tempfile
import urllib.request
import pprint

keys = [
    'name',
    'description',
    'homepage',
    'private',
    'has_issues',
    'has_wiki',
    'has_downloads',
    'default_branch',
]

def read_json(fp):
    with fp:
        data = fp.read()
        data = data.decode('UTF-8')
        return json.loads(data)

def run_editor(file):
    editor = subprocess.check_output(['git', 'var', 'GIT_EDITOR'])
    editor = editor.strip()
    subprocess.check_call([editor + b' "$@"', editor, file.name], shell=True)

class http(object):

    def _request(self, method, url, *, data=None):
        token = os.environ['GITHUB_TOKEN']
        headers = {
            'User-Agent': 'github-editmeta (https://github.com/jwilk/github-editmeta)',
            'Authorization': ('token ' + token),
            'Accept': 'application/vnd.github.v3+json',
        }
        url = urllib.parse.urljoin('https://api.github.com', url)
        request = urllib.request.Request(url, headers=headers, method=method, data=data)
        try:
            return urllib.request.urlopen(request)
        except urllib.error.HTTPError as exc:
            pprint.pprint(read_json(exc), stream=sys.stderr)
            raise

    def get(self, url):
        return self._request('GET', url)

    def patch(self, url, *, data):
        return self._request('PATCH', url, data=data)

http = http()

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('repo', metavar='REPO')
    options = ap.parse_args()
    repo = options.repo
    repo_url = '/repos/' + repo
    response = http.get(repo_url)
    orig_data = read_json(response)
    config = configparser.ConfigParser(interpolation=None)
    config[repo] = {}
    for key in keys:
        value = orig_data[key]
        if isinstance(value, bool):
            value = ('no', 'yes')[value]
        elif value is None:
            value = ''
        config[repo][key] = value
    with tempfile.NamedTemporaryFile(prefix='github-editmeta.', suffix='.ini', mode='w+t') as ini:
        config.write(ini)
        ini.flush()
        run_editor(ini)
        ini.seek(0)
        config = configparser.ConfigParser(interpolation=None)
        config.read_file(ini)
    data = {}
    for key in keys:
        orig_value = orig_data[key]
        try:
            if isinstance(orig_value, bool):
                value = config.getboolean(repo, key)
            else:
                value = config.get(repo, key)
                if not value.strip():
                    value = None
        except configparser.NoOptionError:
            continue
        data[key] = value
    json_data = json.dumps(data).encode('UTF-8')
    http.patch(repo_url, data=json_data)

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
